<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!--
    一、内存管理是什么？
    内存管理是指堆内存的管理，因为只有堆内存是由我们程序员自己控制的，每块堆内存都会有如下生命周期：
    * 分配：申请分配一块堆内存
    * 使用：使用分配到的堆内存
    * 释放：不需要使用这块堆内存时，释放掉

    不同的编程语言对于分配和释放有不同的实现：
    * 手动管理内存：如C、C++、MRC时期的OC......
    * 自动管理内存：ARC时期的OC、Swift、Dart、Java、JS、Python......
      * 引用计数机制：ARC时期的OC、Swift
      * 可达性机制：Dart、Java、JS、Python
  -->

  <!--
    二、JS是如何进行内存管理的？
    垃圾回收的英文是Garbage Collection，简称GC
    对于那些不再被使用的堆内存，我们称之为垃圾，GC会自动释放掉这些垃圾堆内存

    引用计数机制和可达性机制都是典型的GC算法
    我们已经非常熟悉OC、Swift里的引用计数机制了，而JS引擎则是通过可达性机制来实现GC的
    
    那这个可达性机制到底是怎么一回事呢？
    * 可达性机制首先会在堆内存中创建一个根对象root object（JS里这个根对象就是全局window对象）
    * 然后GC会定期（销毁时机不定、由GC算法决定、一般都是等CPU空闲时处理）从这个根对象开始，查找根对象的属性引用的一级对象、一级对象的属性引用的二级对象、二级对象的属性引用的三级对象......如此一层一层找下去，但凡能找到的对象就比较为可达，找不到的对象就标记为不可达，那些不可达的对象就会被视为垃圾，进而被释放掉
 
    引用计数机制和可达性机制的对比：
    * 引用计数机制势必会带来循环引用问题（对象互相引用、闭包和对象互相引用），需要开发者手动处理随之而来的内存泄漏问题，但是可达性机制下就算发生了循环引用也不会造成内存泄漏，因为只要那个循环引用整体不可达了就会被释放
    * 可达性机制更像是在定期轮询所有对象的可达性，而引用计数机制则更像是一个双向通信、当对象不被引用时会主动被告知、然后释放，因此引用计数机制的效率更高
  -->
</body>

</html>