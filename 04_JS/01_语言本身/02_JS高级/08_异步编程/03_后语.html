<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!--
    一、进程和线程
    进程就是指操作系统上正在运行的应用程序，一个正在运行的应用程序就是一个进程（不过浏览器这个正在运行的应用程序可不仅仅是一个进程，而是每打开一个标签就是一个进程，因为如果所有的标签都用一个进程的话，很有可能一个网页卡死了整个浏览器就都卡死了）

    线程就是指一段代码从头到尾的【执行路径】，具体地说比如我们编写的OC代码最终都会被编译成二进制代码供CPU执行，那么CPU在执行这些二进制代码时是从上往下一行一行串行执行的，当遇见if语句或for语句等控制语句时，CPU会偏离当前地址处的二进制代码去执行其它地址处的二进制代码，但执行完后又会返回来执行当前地址处的二进制代码，直到二进制代码执行完毕，这样一段代码从头到尾的执行路径就被称为一个线程

    每个进程中至少会有一条线程，这个线程被称为主线程
  -->

  <!--
    二、单线程和多线程
    单线程就是指进程里”只有一条“主线程（JS被设计为单线程的，但是我们可以通过workers来实现多线程开发、以免阻塞主线程，类似于Flutter里的isolate，不过workers和isolate与传统多线程不完全一样，它们不能直接访问主线程里的数据，只能通过消息传递的方式与主线程进行通信；但其实每个网页的进程里除了主线程外，还有一些其它的默认线程，所以并不是绝对的单线程）

    而开辟一个新线程就是指把某段代码的执行路径和另一段代码的执行路径给完全独立开来，成为CPU的一个单独调度单位，所以当一个进程中有多个这样独立的代码的执行路径时，就是多线程。使用多线程的好处是可以提高程序的执行效率，使用多线程的坏处是开辟过多的线程会占用大量内存和CPU资源，而且还会存在数据竞争问题，因此通常开三到五个线程就差不多了。我们都知道一个CPU一次只能调度一个线程，那苹果是怎么实现多线程并发的呢？原来苹果会让CPU一会儿执行线程1，一会执行线程2，当线程之间的切换时间足够短时，就让我们感觉CPU是在一次执行多个线程，而现在设备都是多核的了，就不仅仅是“感觉”了，而是真得可以利用多个CPU来实现多线程并发
  -->

  <!--
    三、立即执行事件

    执行下面的代码，我们发现打印为：
    111
    222
    333
    这很正常，我们把不是异步耗时操作的代码都称之为立即执行事件，JS引擎在遇到它们时会立即把它们放到主线程里去执行
  -->
  <script>
    // console.log(111);
    // console.log(222);
    // console.log(333);
  </script>

  <!--
    四.1、宏任务事件

    执行下面的代码，我们发现打印为：
    111
    222
    333
    延时0s后
    延时5s后

    那这段代码是怎么执行的呢？
    1、JS引擎在遇到”console.log(111);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了111
    2、JS引擎在遇到”setTimeout“时，setTimeout这个函数本身还是个立即执行事件、它携带的那个回调函数本身是个宏任务事件（因为它不会被立即执行、而是会被放到宏任务队列里）、这里的耗时操作实际上是那5s钟的倒计时，所以会立即把setTimeout这个函数本身放到主线程里去执行，而执行它的效果就是开启一个定时器开始倒计时5s钟，定时器启动后setTimeout这个函数本身的使命就结束了，于是可以继续执行后面的代码，而不至于阻塞在这里，但是有两个疑问：
      * ① 那为什么不会阻塞在这里呢？这是因为浏览器设计这个倒计时操作不是由主线程来倒计时的，而是由其它的默认线程来倒计时的，也就是说主线程不会卡在这一直数5s钟才能往后执行，而是可以立即往后执行
      * ② 那setTimeout函数携带的那个回调函数是怎么处理的呢？这个回调函数会一直放在那，直到其它线程里对应的那个倒计时结束，JS引擎才会把这个回调函数放到宏任务队列里（注意放进宏任务队列的时机是倒计时结束的那一刻，而不是执行setTimeout函数时就放进去），然后这个回调函数就是乖乖等待被调用了，也就是说JS引擎在执行完所有的立即执行事件后，才会去宏任务队列里拿宏任务事件来执行，【这也是为什么我们说定时器可能不太准的原因，就是因为就算倒计时结束了，回调函数也立即被放进宏任务队列里了，但万一此时有个立即执行事件非常耗时、还没执行完呢，那这个回调函数肯定要等人家执行完才能被执行了，所以有可能会滞后】
    3、JS引擎在遇到”console.log(222);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了222
    4、JS引擎在遇到”setTimeout“时，setTimeout这个函数本身还是个立即执行事件、它携带的那个回调函数本身是个宏任务事件（因为它不会被立即执行、而是会被放到宏任务队列里）、这里的耗时操作实际上是那0s钟的倒计时，所以会立即把setTimeout这个函数本身放到主线程里去执行，而执行它的效果就是开启一个定时器开始倒计时0s钟，定时器启动后setTimeout这个函数本身的使命就结束了，于是可以继续执行后面的代码，而不至于阻塞在这里，但是有一个疑问：
      * 延时0s钟、那携带的那个回调函数到底是立即执行事件还是宏任务事件？只要用了setTimeout，不管延时多长时间、就算是延时0s钟，携带的那个回调函数也是宏任务事件，【所以别看着是延时0s钟就觉得那个回调函数会立即执行，实际上那个回调函数会绕一大圈才被执行————其它线程启动定时器、定时器倒计时结束后那个回调函数被放入宏任务队列、所有的立即执行事件执行完毕后才执行那个回调函数】，所以它肯定会晚于333的执行————因为人家333是个立即执行事件
    5、JS引擎在遇到”console.log(333);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了333
    6、打印完333，所有的立即执行事件就都执行完了，所以JS引擎就会去宏任务队列里拿宏任务事件来执行，而延时0s的那个回调函数是先被放进队列里的，所以会先被执行，延时5s的那个回调函数是后被放进队列里的，所以会后被执行，于是依次打印延时0s后、延时5s后
  -->
  <script>
    // console.log(111);

    // setTimeout(() => {
    //   console.log("延时5s后");
    // }, 5000);

    // console.log(222);

    // setTimeout(() => {
    //   console.log("延时0s后");
    // }, 0);

    // console.log(333);
  </script>

  <!--
    四.2、宏任务事件

    执行下面的代码，我们发现打印为：
    111
    222
    333
    当我们点击按钮时，打印：
    点击了按钮

    那这段代码是怎么执行的呢？
    1、JS引擎在遇到DOM操作那一段代码时，因为它们都是立即执行事件，所以会立即把它们放到主线程里去执行，需要注意的是：button.onclick回调函数仅仅是被赋值给了button.onclick属性，这段代码的使命就算完成了，回调函数不会被立即触发
    2、JS引擎在遇到console.log那一段代码时，因为它们都是立即执行事件，所以会立即把它们放到主线程里去执行，所以依次打印了111、222、333
    3、当我们点击按钮时，JS引擎才会把button.onclick回调函数放到宏任务队列里（注意放进宏任务队列的时机是点击按钮那一刻，而不是给button.onclick属性赋值时就放进去），与此同时，JS引擎发现所有的立即执行事件都执行完了，所以就会去宏任务队列里拿宏任务事件来执行，所以打印了“点击了按钮”，【这也是为什么我们说单线程容易出现UI卡顿的原因，因为很有可能用户点击了某个按钮，但是主线程里的立即执行事件还没执行完，那这个点击事件就无法及时响应了】
  -->
  <button>按钮</button>
  <script>
    // const buttonEle = document.querySelector("button");
    // buttonEle.onclick = function () {
    //   console.log("点击了按钮");
    // }

    // console.log(111);
    // console.log(222);
    // console.log(333);
  </script>

  <!--
    五、微任务事件

    执行下面的代码，我们发现打印为：
    111
    222
    333
    444
    Promise.then被触发了

    那这段代码是怎么执行的呢？
    1、JS引擎在遇到”console.log(111);“这个立即执行事件时，会立即把它放到主线程里去执行，所以打印了111
    2、JS引擎在遇到创建Promise的那段代码时：
      * 我们之前说过Promise的executor函数会在Promise对象被创建出来后立即调用，所以它们也都是立即执行函数，所以不是执行后面的444，而是先执行executor函数
      * executor函数里会先打印222，然后执行resolve函数、resolve函数本身是个立即执行函数、它被执行后，JS引擎会立即把then监听的第一个函数放到微任务队列里，但是不会立即执行then监听的第一个函数，此时resolve函数的使命就已经完成了，然后继续打印333
    3、打印完333后，JS引擎发现还有444这个立即执行事件需要做，所以又会打印444
    4、等所有的立即执行事件都执行完了，JS引擎就会去微任务队列里拿微任务事件来执行，于是打印了“Promise.then被触发了”
  -->
  <script>
    console.log(111);

    new Promise((resolve, reject) => {
      console.log(222);

      resolve();

      console.log(333);
    }).then(
      (value) => {
        console.log("Promise.then被触发了");
      },
    );

    console.log(444);
  </script>

  <!--
    六、立即执行事件、微任务事件、宏任务事件的执行优先级及事件循环
    立即执行事件：就是我们常规的代码
    微任务事件（一定的时机会被加入到微任务队列里）：主要包含Promise.then回调等
    宏任务事件（一定的时机会被加入到宏任务队列里）：主要包含setTimeout、setInterval、DOM监听、Ajax请求的回调、UI Rendering等
 
    立即执行事件 > 微任务事件 > 宏任务事件
    立即执行事件的优先级最高，JS引擎肯定是执行完所有的立即执行事件后才会去执行其它事件
    当所有的立即执行事件都执行完毕后，JS引擎就会去微任务队列里拿微任务事件来执行，等所有的微任务事件都执行完毕后，才去宏任务队列里拿一个宏任务事件来执行，而等这个宏任务事件执行完毕后不是立马执行下一个宏任务事件，而是会再次去微任务队列里拿微任务事件来执行（因为上一个宏任务事件执行过程中，可能又产生了新的微任务事件），等这一波微任务事件都执行完毕后，再去宏任务队列里拿一个宏任务事件来执行，如此循环......

    而这种一遍一遍不停地检查和执行事件的机制就是JS里面的事件循环（Event Loop）
  -->
</body>

</html>