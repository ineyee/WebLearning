<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!--
    二、Promise实现异步开发
    既然定义和调用异步任务函数这两步会存在不统一的困境，那让这两步统一不就完事了嘛，这就是Promise做的事情，所有的开发者都得按Promise的固定写法来写！
  -->
  <!--
    1、Promise实现异步开发和回调函数实现异步开发不同的地方
    ——————————————————————
    * 定义阶段：
      * （1）针对异步任务函数的【参数】参来说：原来我们是自定义succesCallback、failureCallback等回调函数来上报耗时操作的结果，现在Promise对象的executor函数自带了两个函数resolve（即成功上报函数）和reject（即失败上报函数）来让我们上报耗时操作的结果，所以我们不再需要写回调函数这样的参数了
      * （2）针对异步任务函数的【返回值】参来说：原来是没有返回值的，现在我们需要返回一个Promise对象、以便外界监听耗时操作的结果
      * （3）针对异步任务函数的【执行体】参来说：
        * ① 原来我们是把耗时操作直接放在异步任务函数里执行的，现在需要创建一个Promise对象并把耗时操作放在Promise对象的executor函数里执行（Promise对象一旦创建、就会立即执行它的executor函数）
        * ② 原来我们是通过回调函数上报耗时操作的结果的，现在需要通过Promise对象的executor函数自带的两个函数resolve（即成功上报函数）和reject（即失败上报函数）来上报耗时操作的结果
    ——————————————————————
    * 调用阶段：
      * （1）原来我们是通过传给异步任务函数的回调函数来拿到耗时操作的结果的，现在我们是通过调用异步任务函数先拿到一个Promise对象，然后再通过Promise对象的then方法来监听耗时操作的结果，那监听什么时候会被触发呢？Promise对象的executor函数里一旦调用了resolve（即成功上报函数）函数、就一定会触发then监听的第一个函数（即成功），executor函数里一旦调用了reject（即失败上报函数）函数、就一定会触发then监听的第二个函数（即失败）
  -->
  <script>
    // 这整个函数是异步任务 = 执行耗时操作 + Promise的一套机制
    function getWiFiList() {
      // 创建Promised对象
      const promise = new Promise((resolve, reject) => {
        // 这里是耗时操作，我们用延时来模拟耗时操作
        setTimeout(() => {
          // 2000ms后，耗时操作执行完毕，主动上报结果
          // 成功时
          resolve({
            "code": 0,
            "data": ["Wi-Fi01", "Wi-Fi02"],
          });
          // 失败时
          // reject({
          //   "code": 404,
          //   "data": [],
          // });
        }, 2000);
      });

      // 返回Promised对象
      return promise;
    }

    // 发起异步任务，先拿到Promise对象，然后监听异步任务的结果
    const promise = getWiFiList();
    promise.then(
      (result) => {
        console.log(`蓝牙设备响应成功：${result["data"]}`);
      },
      (error) => {
        console.log(`蓝牙设备响应失败：${error["code"]}`);
      },
    );
  </script>

  <!--
    2、Promise实现异步开发的固定写法（实际开发中使用Promise时，我们90%都是在写这种固定的写法，一定要特别熟练形成肌肉记忆）
    注意：then监听里一定要把成功和失败监听都写上，否则executor函数里触发then监听时项目会崩掉
    ——————————————————————
    // （1）定义异步任务函数阶段
    function asyncFunc() {
      const promise = new Promise((resolve, reject) => {
        // 执行耗时操作...

        // 耗时操作执行成功时，用resolve函数上报
        resolve(data);

        // 耗时操作执行失败时，用reject函数上报
        reject(error);
      });

      return promise;
    }
    ——————————————————————
    // （2）调用异步任务函数阶段
    const promise = asyncFunc();
    promise.then(
      (result) => {
        // 异步任务执行成功的监听
      },
      (error) => {
        // 异步任务执行失败的监听
      },
    )
    ——————————————————————
  -->

  <!--
    3、Promise对象的3种状态
    * pending（待处理状态）：我们创建出来一个Promise对象，如果从来没调用过它的resolve或reject上报数据，那它就会一直处于pending状态
    * fulfilled（成功状态）：一旦调用resolve上报数据，Promise对象就会由pending状态锁定为fulfilled状态、不会再更改
    * rejected（失败状态）：一旦调用reject上报数据，Promise对象就会由pending状态锁定为rejected状态、不会再更改
  -->
  <script>
    (new Promise()).sta
  </script>
</body>

</html>