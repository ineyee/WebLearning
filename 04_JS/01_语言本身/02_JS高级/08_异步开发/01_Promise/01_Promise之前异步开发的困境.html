<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!--
    一、Promise之前异步开发的困境
  -->
  <!--
    1、首先回顾下什么是异步任务
    耗时操作：如果一个操作耗时比较长、不是代码执行级别的耗时，那这个操作就是一个耗时操作

    同步任务：我们发起任务后，一直阻塞在那等待耗时操作执行完毕拿结果，那这个任务就是个同步任务
    异步任务：我们发起任务后，不阻塞在那等待耗时操作的执行，而是继续执行其它任务，耗时操作执行完毕后主动把结果告诉我们，那这个任务就是个异步任务。也就是说但凡得等一会儿才能拿到执行结果的任务就是异步任务，比如网络请求、本地I/O操作、蓝牙协议通信等等
  -->

  <!--
    2、再来回顾下Promise之前我们是怎么实现异步开发的——回调函数实现异步开发
    假设我们要实现一个蓝牙协议通信，App向蓝牙设备获取附近Wi-Fi列表
  -->
  <script>
    // 这整个函数是异步任务 = 执行耗时操作 + 通过回调函数上报耗时操作的结果
    function getWiFiList(succesCallback, failureCallback) {
      // 这里是耗时操作，我们用延时来模拟耗时操作
      setTimeout(() => {
        // 2000ms后，耗时操作执行完毕，主动上报结果
        // 成功时
        succesCallback({
          "code": 0,
          "data": ["Wi-Fi01", "Wi-Fi02"],
        });
        // 失败时
        // failureCallback({
        //   "code": 404,
        //   "data": [],
        // });
      }, 2000);
    }

    // 发起异步任务
    getWiFiList(
      (result) => {
        console.log(`蓝牙设备响应成功：${result["data"]}`);
      },
      (error) => {
        console.log(`蓝牙设备响应失败：${error["code"]}`);
      },
    );
  </script>

  <!--
    3、回调函数实现异步开发的困境
    很长一段时间内我们都是通过回调函数实现异步开发的，这样做绝对没问题，但是存在弊端：
    * （1）定义异步任务函数————如上面的getWiFiList函数————的人很可能只写了success回调函数而没写failure回调函数，又或者failure回调函数写在了success回调函数前面，总之每个人有每个人的风格和习惯，无法统一
    * （2）这就进而导致调用异步任务函数————getWiFiList()————的人在使用时得非常小心，甚至得看函数的源码才能知道该怎么传回调函数进去，避免传错

    既然定义和调用异步任务函数这两步会存在不统一的困境，那让这两步统一不就完事了嘛，这就是Promise做的事情！
  -->
</body>

</html>