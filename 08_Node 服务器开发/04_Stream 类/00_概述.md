## Stream 是什么

* 当我们提到流的时候，很自然地会想到水流，水流有一个很重要的特点就是它在【连续不断地动】，我们并不会把一滩不动的死水称之为流，一定要记住流肯定是动的
* 对应到代码的世界里，流就是一个【连续不断地动】的数据流，又因为在代码的世界里所有的数据都是用二进制表示的，而且在大多数情况下我们都是用一个字节一个字节地表示，所以更具体地说流就是一个【连续不断地动】的字节流。当然如果一堆二进制数据写死在文件里不动，那么我们并不会把它称之为流，它就是一个静态的数据块。只有二进制数据动起来，我们才会把它称之为流，比如我们把二进制数据从文件中读取出来的过程中或者把二进制数据写入到文件的过程中，这个过程中的二进制数据就是在流动的，它才是流；又比如上传下载文件的过程中，文件的二进制数据也是在流动的，它也是流；又比如直播时音频和视频的推流拉流，音频和视频的二进制数据也是在流动的，它也是流...，一定要记住流肯定是动的

## 为什么需要 Stream

* 比如我们前面已经学习了 readFile 和 writeFile 这样的 API 来读写文件，但是这类 API 都是一次性把二进制数据给读取和写入的，这仅仅适用于读写小文件和读写过程不需要细节控制的情况。而且这种情况下的读写二进制数据并没有体现出流的特点，所以这类 API 并不是流式读写文件
* 倘若一个文件非常大，比如一个视频文件有几个 G，那么我们一次性把这么大的文件读取到应用程序内存中，交给播放器框架去播放显然是不现实的，肯定会导致 OOM，所以这时候我们就需要用到流式读写文件的 API，它可以把文件分成很多小块，然后一块一块地读取和写入，这样就可以避免一次性把大文件读取到内存中，这种情况下下的读写二进制数据就体现出来的流的特点————一点一点、连续不断地读写二进制数据
* 此外如果我们想在读写二进制文件的过程中进行一些细节控制，比如读写到某个位置后暂停读写、下次再从这个位置继续读写来实现断点续传功能；又比如指定读写的开始位置、指定读写的结束位置等操作；这都得用流式读写文件的 API 才能实现

## Stream 的分类

* Node 中的 Stream 类是一个抽象类，它有很多子类：
  * ReadableStream：表示一个可读的数据流，比如从一个文件里读取数据时，就可以用它
  * WritableStream：表示一个可写的数据流，比如向一个文件里写入数据时，就可以用它
  * DuplexStream：表示一个可读可写的数据流，比如在 socket 通信中既可以读取数据也可以写入数据，就可以用它
  * TransformStream：表示一个可读可写的数据流，比如在读取一个文件的同时需要对文件数据进行加密，就可以用它
* 另外我们需要知道，Node 中所有的 Stream 类都继承自 EventEmitter 类，所以它们都具有 EventEmitter 类的属性和方法，也就是说它们都能监听事件、也能触发事件
* 另外我们还需要知道，Node 中 http 模块的 request 和 response 对象都是 Stream 类的实例，所以它们都具有 Stream 类的属性和方法。request 其实就是一个 ReadableStream，用来读取客户端发过来的请求数据；response 其实就是一个 WritableStream，用来写入响应数据给客户端