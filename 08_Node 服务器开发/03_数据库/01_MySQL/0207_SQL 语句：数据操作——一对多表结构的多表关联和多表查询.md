`错误理解：`
* `一对多表结构是指只有一张表有外键，其它表都没有外键，有外键的这张表通过外键引用着没有外键的那些表。`比如歌曲表有外键，歌手表没有外键，歌曲表通过外键引用着歌手表表明其所属的歌手
* `多对多表结构是指表1有外键，表2也有外键，表1通过外键引用着表2，表2又通过外键引用着表1。`比如歌曲表有外键，歌手表也有外键，歌曲表通过外键引用着歌手表表明其所属的歌手，歌手表又通过外键引用着歌曲表表明其拥有的歌曲

`正确理解：`

* `首先我们需要知道，实际开发中，我们一般不会设计出表与表之间互相引用的表结构（因为循环引用会导致数据操作变得非常复杂，操作风险也非常高，循环引用的表结构最终会转化成多对多表结构来实现），而都是设计成单向引用的表结构，至于是设计成一对多的表结构还是多对多的表结构，要考虑清楚`
* `一对多表结构是指外键的值只可能是一个值，而不可能是数组的情况，这种情况直接在“多方”表里添加外键即可。`比如下面的例子中，歌曲表里外键都是固定的一个值（单唱歌曲的一首歌只属于一个歌手）
* `多对多表结构是指外键的值可能是数组，而不仅仅是一个值的情况，这种情况我们就需要引用中间表来实现了。`比如下一篇的例子中，歌曲表里外键都是多个值组成的数组（合唱歌曲的一首歌同时属于多个歌手）

`因此在设计表结构时可以按如下思路：`

* `第一步：先根据业务场景确定有多少个对象，进而确定需要创建几张表，比如需要创建歌手表和歌曲表`
* `第二步：再根据逻辑关系确定谁是多方谁是一方，进而决定外键应该添加在哪张表里，比如一个歌手可能有多首歌曲，所以歌手表是一方、歌曲表是多方，外键应该创建在歌曲表里`
* `第三步：然后看看外键的值只可能是一个值还是可能是多个值，进而决定是采用一对多表结构还是多对多表结构，一对多表结构时直接在多方表里添加外键就行了，多对多表结构时就需要引用中间表来实现了，比如只有单唱歌曲、单唱歌曲的一首歌只属于一个歌手、那就可以采用一对多表结构，如果有合唱歌曲、合唱歌曲的一首歌同时属于多个歌手、那就得用多对多表结构`

## 一、多表关联的实现

#### 1、场景一：最初设计表和创建表的时候，我们已经确定好了表与表之间的关系

比如我们设计了如下歌曲表和歌手表

|id（主键）|name|cover|singerId（外键）|
|:-:|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|1|
|2|晴天|https://晴天.jpg|1|
|3|贝加尔湖畔|''|2|
|4|画|https://画.jpg|NULL|
|5|成都|https://成都.jpg|NULL|

|id（主键）|name|sex|
|:-:|:-:|:-:|
|1|周杰伦|''|
|2|李健|男|
|3|梁静茹|女|

那么创建歌曲表和歌手表，先创建没有外键的那个表，再创建有外键的那个表

```SQL
CREATE TABLE IF NOT EXISTS `t_singer` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(100) NOT NULL,
  `sex` VARCHAR(100) DEFAULT('')
);
```

```SQL
CREATE TABLE IF NOT EXISTS `t_song` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(100) NOT NULL,
  `cover` VARCHAR(100) DEFAULT(''),
  -- 必须与 t_singer.id 类型一致
  `singerId` BIGINT,
  -- 在 CREATE 语句的最后添加一个外键约束，含义为：
  -- 当前表中的外键 `singerId`，引用的是 `t_singer` 表中的 `id`
  -- ON UPDATE 和 ON DELETE 是指当我们删除或修改 t_singer.id 时，t_song 应该做出什么反应，默认情况下是这个值是 RESTRICT —— 即如果某个字段被外键关联着、那么在删除或修改这个字段时直接报错、也就是说不允许删除或修改；我们通常会手动设置为 CASCADE —— 即允许删除或修改这个字段、并且如果是删除这个字段那就跟随删除另外一张表里的数据、如果是修改这个字段那就跟随修改另外一张表里的数据
  FOREIGN KEY (`singerId`) REFERENCES `t_singer`(`id`) ON UPDATE CASCADE ON DELETE CASCADE
);
```

#### 2、场景二：最初设计表和创建表的时候，我们没有确定好表与表之间的关系，后续开发需要补充

比如最初我们只设计和创建了歌曲表

|id（主键）|name|cover|
|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|
|2|晴天|https://晴天.jpg|
|3|贝加尔湖畔|''|
|4|画|https://画.jpg|
|5|成都|https://成都.jpg|

```SQL
CREATE TABLE IF NOT EXISTS `t_song` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(100) NOT NULL,
  `cover` VARCHAR(100) DEFAULT('')
);
```

但是随着业务的发展，我们发现需要新增一张歌手表，并将歌曲表和歌手表关联起来，于是我们就设计和创建了一张歌手表

|id（主键）|name|sex|
|:-:|:-:|:-:|
|1|周杰伦|''|
|2|李健|男|
|3|梁静茹|女|

```SQL
CREATE TABLE IF NOT EXISTS `t_singer` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(100) NOT NULL,
  `sex` VARCHAR(100) DEFAULT('')
);
```

等两个表都存在后，将歌曲表和歌手表通过外键关联起来

```SQL
-- 先给歌曲表添加一个外键，必须与 t_singer.id 类型一致
ALTER TABLE `t_song` ADD `singerId` BIGINT;
```

```SQL
-- 然后通过这个外键将两个表关联起来
ALTER TABLE `t_song` ADD FOREIGN KEY (`singerId`) REFERENCES `t_singer`(`id`) ON UPDATE CASCADE ON DELETE CASCADE;
```

## 二、多表查询的实现

**查询的格式如下：**

```
SELECT 表达式1, 表达式2, ...
FROM 表1
[LEFT | RIGHT | INNER/CROSS | FULL] JOIN 表2
ON 表1.外键 = 表2.主键
WHERE 查询条件
ORDER BY 要按照哪个字段来进行排序 ASC(代表升序) | DESC(代表降序)
LIMIT 这一次拿多少条数据 OFFSET 这一次从哪个偏移位置开始拿数据
```

## 1、左连接（实际开发中用得多）

> 左连接的效果是`以表1为主`，也就是说：
> 
> * 肯定会把表1里所有的数据都查询出来，就算表1里某些数据的外键没有匹配上表2里的主键
> * 而表2里的数据则只会查询出来那些能匹配上表1外键的，匹配不上的会被过滤掉

```SQL
SELECT
-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
  `t_song`.`id` AS `songId`,
  `t_song`.`name` AS `songName`,
  `t_song`.`cover` AS `songCover`,
  `t_singer`.`id` AS `singerId`,
  `t_singer`.`name` AS `singerName`,
  `t_singer`.`sex` AS `singerSex`
-- `t_song`是表1
FROM `t_song`
-- `t_singer`是表2
LEFT JOIN `t_singer`
ON `t_song`.`singerId` = `t_singer`.`id`;
```

查询结果如下，可见：
* 的确把表1——即歌曲表——里所有的数据都查询出来了，就算画和成都这两首歌在表2——即歌手表——里没有匹配的数据
* 而表2里数据只查询出来了匹配到表1的数据，像梁静茹就被过滤掉了

|songId|songName|songCover|singerId|singerName|singerSex|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|1|周杰伦|''|
|2|晴天|https://晴天.jpg|1|周杰伦|''|
|3|贝加尔湖畔|''|2|李健|男|
|4|画|https://画.jpg|NULL|NULL|NULL|
|5|成都|https://成都.jpg|NULL|NULL|NULL|

## 2、右连接（实际开发中用得不多）

> 右连接的效果是`以表2为主`，也就是说：
> 
> * 肯定会把表2里所有的数据都查询出来，就算表2里某些数据的主键没有匹配上表1的外键
> * 而表1里的数据则只会查询出来那些能匹配上表2主键的，匹配不上的会被过滤掉

```SQL
SELECT
-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
  `t_song`.`id` AS `songId`,
  `t_song`.`name` AS `songName`,
  `t_song`.`cover` AS `songCover`,
  `t_singer`.`id` AS `singerId`,
  `t_singer`.`name` AS `singerName`,
  `t_singer`.`sex` AS `singerSex`
-- `t_song`是表1
FROM `t_song`
-- `t_singer`是表2
RIGHT JOIN `t_singer`
ON `t_song`.`singerId` = `t_singer`.`id`;
```

查询结果如下：

|songId|songName|songCover|singerId|singerName|singerSex|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|1|周杰伦|''|
|2|晴天|https://晴天.jpg|1|周杰伦|''|
|3|贝加尔湖畔|''|2|李健|男|
|NULL|NULL|NULL|3|梁静茹|女|

## 3、内连接（实际开发中用得多）

> 内连接的效果是`以表1和表2为主`，也就是说：
> 
> * 只会查询出那些表1和表2里表1.外键匹配上表2.主键的数据
> * 不管你是表1还是表2里的数据，只要没匹配上就会被过滤掉

```SQL
SELECT
-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
  `t_song`.`id` AS `songId`,
  `t_song`.`name` AS `songName`,
  `t_song`.`cover` AS `songCover`,
  `t_singer`.`id` AS `singerId`,
  `t_singer`.`name` AS `singerName`,
  `t_singer`.`sex` AS `singerSex`
-- `t_song`是表1
FROM `t_song`
-- `t_singer`是表2，INNER 或 CROSS 可以省略
INNER JOIN `t_singer`
ON `t_song`.`singerId` = `t_singer`.`id`;
```

查询结果如下：

|songId|songName|songCover|singerId|singerName|singerSex|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|1|周杰伦|''|
|2|晴天|https://晴天.jpg|1|周杰伦|''|
|3|贝加尔湖畔|''|2|李健|男|

## 4、全连接（实际开发中用得不多）

> 全连接的效果是`以表1和表2为主`，也就是说：
> 
> * 会查询出表1和表2里所有的数据
> * 一条都不会过滤
> 
> SQL 规范中全连接是使用 FULL JOIN，但是 MySQL 中没有实现 FULL JOIN，所以我们需要用“左连接 UNION 右连接”来实现全连接的效果

```SQL
(
  SELECT
  -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    `t_song`.`id` AS `songId`,
    `t_song`.`name` AS `songName`,
    `t_song`.`cover` AS `songCover`,
    `t_singer`.`id` AS `singerId`,
    `t_singer`.`name` AS `singerName`,
    `t_singer`.`sex` AS `singerSex`
  -- `t_song`是表1
  FROM `t_song`
  -- `t_singer`是表2
  LEFT JOIN `t_singer`
  ON `t_song`.`singerId` = `t_singer`.`id`
)
UNION
(
  SELECT
  -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    `t_song`.`id` AS `songId`,
    `t_song`.`name` AS `songName`,
    `t_song`.`cover` AS `songCover`,
    `t_singer`.`id` AS `singerId`,
    `t_singer`.`name` AS `singerName`,
    `t_singer`.`sex` AS `singerSex`
  -- `t_song`是表1
  FROM `t_song`
  -- `t_singer`是表2
  RIGHT JOIN `t_singer`
  ON `t_song`.`singerId` = `t_singer`.`id`
);
```

查询结果如下：

|songId|songName|songCover|singerId|singerName|singerSex|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|七里香|https://七里香.jpg|1|周杰伦|''|
|2|晴天|https://晴天.jpg|1|周杰伦|''|
|3|贝加尔湖畔|''|2|李健|男|
|4|画|https://画.jpg|NULL|NULL|NULL|
|5|成都|https://成都.jpg|NULL|NULL|NULL|
|NULL|NULL|NULL|3|梁静茹|女|