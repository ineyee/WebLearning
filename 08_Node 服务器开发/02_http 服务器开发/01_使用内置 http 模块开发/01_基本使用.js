// 第一步：导入 http 模块
const http = require("http");

// 第二步：创建一个 http 服务器实例
const httpServer = http.createServer();

// 第三步：指定要监听的端口并启动 http 服务器
// 第一个参数：要监听的端口（即服务要部署在哪个端口上）
// 第二个参数：http 服务器启动成功后的回调函数
// 
// 因为我们编写的这份代码（即服务）会部署在某个特定的服务器上（即主机），将来客户端访问时会通过 IP 地址或域名来找到相应的服务器，所以是不需要指定主机的，只需要指定端口即可
httpServer.listen(8000, () => {
  console.log("🚀服务器启动成功🚀");
});

// 第四步：监听来自客户端的请求并返回响应
// 第一个参数：请求事件（即客户端请求服务器时会触发该事件）
// 第二个参数：回调函数，回调函数中会传入两个参数，分别是请求对象（req）和响应对象（res）
//    请求对象（request）：本质就是一个 ReadableStream，用来读取客户端发过来的请求数据。包含了客户端请求服务器时的所有信息，如请求方法、请求路径、请求头、请求体等
//    响应对象（response）：本质就是一个 WritableStream，用来写入响应数据给客户端。包含了服务器要返回给客户端的所有信息，如响应状态码、响应头、响应体等
httpServer.on("request", (req, res) => {
  // 比如获取请求方法
  console.log(req.method);

  // 比如返回响应
  res.end("Hello World");
});

// 第五步：手动运行 http 服务器测试看看效果（实际部署的话，我们不需要手动运行，而是交给服务器自动运行，部署流程后面专门说）
// cd 到当前文件夹，执行“node 01_基本使用.js”命令，服务器就运行起来了
// 打开 Postman，访问 http://localhost:8000 或 http://127.0.0.1:8000（因为手动运行时服务器是跑在本地的，所以访问时是通过 localhost 或 127.0.0.1 来访问）就可以了
// 注意：通过 node 来手动运行，每次修改了服务器的代码后，都需要重新运行服务器，否则服务器不会自动更新
// 
// 所以为了让服务器能在修改代码后自动更新，我们可以使用 nodemon 工具来运行服务器
// 首先执行命令全局安装 nodemon：npm install nodemon -g
// 然后使用 nodemon 运行服务器：cd 到当前文件夹，执行“nodemon 01_基本使用.js”命令，服务器就运行起来了

// =============================== http 服务器开发概念讲解 ===============================
/*
  概念一：主机（host）

  定义：
    * 主机是指运行服务的物理设备或虚拟设备，物理设备如一台服务器或一台电脑，虚拟设备如一个云服务器实例
    * 主机的标识通常是 IP 地址或域名，IP 地址如 192.168.1.1，域名如 www.example.com
    
  作用：
    * 主要用来运行服务
*/

/*
  概念二：端口（port）

  定义：
    * 端口是主机上的虚拟通道并非真实存在，用于区分不同的服务
    * 端口号是一个 16 位的整数，范围是 0 到 65535
      * 0~1023 是知名端口号，知名端口号是指已经被分配给特定服务的端口号，如 HTTP 服务的默认端口号是 80、HTTPS 服务的默认端口号是 443、MySQL 服务的默认端口号是 3306
      * 1024~65535 是动态端口号，动态端口号是指未被分配给特定服务的端口号，可以由用户自由分配
    
  作用：
    * 一台主机上可以运行多个服务，每个服务可以通过不同的端口来区分
*/

/*
  概念三：服务（service）

  定义：
    * 服务是指运行在主机上的一个应用程序，用于提供特定的功能
    * 如一个 http 服务、一个数据库服务、一个文件传输服务等

  作用：
    * 处理客户端的请求并返回响应，从而实现具体的业务逻辑
*/

/*
  三者关系总结：
    * 主机就是我们的服务器，负责运行服务
    * 服务就是我们编写的代码，被主机运行
    * 而端口则是主机和服务之间的桥梁，因为一台主机上可以部署多个服务，所以我们可以把不同的服务部署在不同的端口上，来达到区分同一个主机上不同服务的效果（但端口和服务不是一对一的关系）
  
  通信流程示例：
    * 客户端通过主机地址（IP 地址或域名）找到目标主机
    * 客户端通过端口号访问特定的服务
    * 服务处理客户端的请求并返回响应
*/

/*
  理解勘误：一台主机上有很多个端口，一台主机上可以运行很多个服务，这没问题，那端口和服务是一对一的关系吗？
  答：不是的，端口和服务不一定是一对一的关系，也有可能是一对多或多对一的关系。总之一个端口可以部署一个服务也可以部署多个服务，并且一个服务也可以部署在多个端口上

  比如：
    * 一台主机上部署了两个服务，一个服务部署在 8080 端口，另一个服务部署在 8081 端口，此时端口和服务就是一对一的关系
    * 一台主机上部署了两个服务，但是这两个服务都部署在了 80 端口（80 端口可以同时用于 HTTP 和 WebSocket 服务），此时端口和服务就是一对多的关系
    * 一台主机上部署了一个服务，但是这个服务既被部署在了 80 端口，又被部署在了 443 端口，同时支持监听 http 和 https 请求，此时端口和服务就是多对一的关系
*/

/*
  理解勘误：一个项目就是一个服务吗？
  答：不是的，这主要看我们用什么架构来部署项目，总之一个项目可以是一个服务，也可以是多个服务

  单体架构：
    * 单体架构是指一个项目中所有的功能模块都集中在一个项目中，这个项目整体作为一个服务部署在一个端口（此时一个项目 = 一个服务）。例如一个音乐播放器项目，里面有用户模块和音乐模块，这个项目整体作为一个服务部署在 8080 端口上，而另一个视频播放器项目，里面有用户模块和音乐模块，这个项目整体作为一个服务部署在 8081 端口上，这就是单体架构
    * 单体架构的优点是部署简单，缺点是扩展性差，因为所有的功能模块都集中在一起，所以一旦某个功能出现问题，整个项目都会受到影响

  微服务架构：
    * 微服务架构是指一个项目中所有的功能都拆分成多个独立的模块，每个模块作为一个独立的服务部署在不同的端口（此时一个项目 = 多个服务）。例如音乐播放器项目和视频播放器项目的用户模块是打通的，所以用户模块就可以作为一个单独的服务部署在 8080 端口上，而音乐模块和视频模块就可以作为两个单独的服务部署在 8081 端口和 8082 端口上，这就是微服务架构
    * 微服务架构的优点是扩展性好，缺点是部署复杂，因为每个项目都需要独立部署，所以需要更多的服务器资源
*/
