/*=================================
  文件 => 读取缓冲区 => 原始数据

  流式读取文件的步骤
  1、创建一个可读流，专门用来读取某个文件
  2、监听流的 open 事件，当打开文件时，就会触发该事件
  3、监听流的 data 事件，每当读取到数据时，就会触发该事件（正是因为 Stream 类继承自 EventEmitter 类）
  4、监听流的 end 事件，当读取到文件的末尾时，就会触发该事件（文件会自动关闭，即流会自动关闭）
  5、监听流的 close 事件，当关闭文件时，就会触发该事件
  6、监听流的 error 事件，当读取文件发生错误时，就会触发该事件
=================================*/

const fs = require("fs");

// 1、创建一个可读流，专门用来读取某个文件
const readStream = fs.createReadStream("./test_read.txt", {
  // 对于大文件，我们可能不希望一次性把全部数据都读取出来，而是一点一点读，这里就可以指定每次读取几个字节，默认 64kB
  // 这里其实是在设置读取缓冲区的大小，只不过表现出来的现象是每次读取几个字节。当我们设置了这个值时，Node.js 会尝试从文件中读取数据来填充这个读取缓冲区，当读取缓冲区被填满时，Node.js 会暂停从文件里读取数据，直到我们通过 data 事件消费了读取缓冲区里的数据后，Node.js 才会继续从文件里读取数据来填充读取缓冲区，如此反复
  // 如果超过数据的总大小，则只会读取一次，然后触发一次 data 事件
  // 如果小于数据的总大小，则每次读取指定的大小，然后触发多次 data 事件
  //    如果数据的总大小刚好是每次读取的整数倍，则刚好触发多次 data 事件
  //    如果数据的总大小不是每次读取的整数倍，则最后一次触发 data 事件时，读取到的数据会小于指定的大小
  highWaterMark: 3,
  // 还可以指定从哪个 index 处开始读，包含
  start: 0,
  // 还可以指定读到哪个 index 处结束，包含
  end: 0 + 18,
});

// 2、监听流的 open 事件，当打开文件时，就会触发该事件
readStream.on("open", () => {
  console.log("文件已打开");
});

// 3、监听流的 data 事件，每当读取到数据时，就会触发该事件（正是因为 Stream 类继承自 EventEmitter 类）
readStream.on("data", (chunk) => {
  console.log(chunk.toString());

  // 还可以读取到某个位置后暂停读取
  readStream.pause();
  // 还可以在想要的时机恢复读取
  setTimeout(() => {
    readStream.resume();
  }, 1000);
});

// 4、监听流的 end 事件，当读取到文件的末尾时，就会触发该事件（文件会自动关闭，即流会自动关闭）
readStream.on("end", () => {
  console.log("数据全部读取完毕了");
});

// 5、监听流的 close 事件，当关闭文件时，就会触发该事件
readStream.on("close", () => {
  console.log("文件已关闭");
});

// 6、监听流的 error 事件，当读取文件发生错误时，就会触发该事件
readStream.on("error", (err) => {
  console.log("读取文件发生错误:", err);
});
