/*=================================
  原始数据 => 写入缓冲区 => 文件

  流式写入文件的步骤
  1、创建一个可写流，专门用来写入某个文件
  2、监听流的 open 事件，当打开文件时，就会触发该事件
  3、调用 write() 方法写入数据，可以多次调用
  4、调用 end() 方法写入最后一波数据，与此同时它还会关闭文件（即关闭流）
  5、监听流的 finish 事件，当写入完成时，就会触发该事件
  6、监听流的 close 事件，当关闭文件时，就会触发该事件
  7、监听流的 error 事件，当写入文件发生错误时，就会触发该事件
=================================*/

const fs = require("fs");

// 1、创建一个可写流，专门用来写入某个文件
const writeStream = fs.createWriteStream("./test_write.txt", {
  // 写入模式：w、w+、a、a+，一般都是用追加
  flags: "a",
  // 可以指定写入缓冲区的大小，默认 16kB，需要注意的是这个值只是写入缓冲区的建议性阈值，而非写入缓冲区的真实大小
  // 当我们调用 write() 方法写入原始数据时，数据会先被添加到写入缓冲区，然后才写入文件
  // 如果 write() 方法写入的原始数据量小于写入缓冲区的大小，这是我们希望的情况，write() 方法会返回 true，表示写入文件成功，我们可以继续写下一波数据
  // 如果 write() 方法写入的原始数据量大于写入缓冲区的大小，这是预警的情况，write() 方法会返回 false，表示现在写数据操作有点拥堵了，建议暂停写入数据，等待 drain 事件触发后再继续写下一波数据
  // 你可能会想如果 write() 方法写入的原始数据量大于写入缓冲区的大小，既然原始数据是先放进写入缓冲区的，那超出部分的数据会被丢掉吗？答案是不会的，超出的数据依然会被放进写入缓冲区，这正是我们上面所说的建议性阈值，而非写入缓冲区的真实大小；只不过如果写入缓冲区满了，我们还是不管不顾继续写数据，那写入缓冲区就会不断地变大变大，最终导致 OOM
  // 不过更多的情况下，我们会主动控制好每次写入的数据不超过写入缓冲区的大小
  highWaterMark: 16 * 1024,
});

// 2、监听流的 open 事件，当打开文件时，就会触发该事件
writeStream.on("open", () => {
  console.log("文件已打开");
});

// 3、调用 write() 方法写入数据，可以多次调用
// 模拟分批写入数据
const timer = setInterval(() => {
  writeStream.write("写入新的一行数据\n");
}, 1000);

// 4、调用 end() 方法写入最后一波数据，与此同时它还会关闭文件（即关闭流）
setTimeout(() => {
  writeStream.end("最后一行数据");
  clearInterval(timer);
}, 3000);

// 5、监听流的 finish 事件，当写入完成时，就会触发该事件
writeStream.on("finish", () => {
  console.log("写入完成");
});

// 6、监听流的 close 事件，当关闭文件时，就会触发该事件
writeStream.on("close", () => {
  console.log("文件已关闭");
});

// 7、监听流的 error 事件，当写入文件发生错误时，就会触发该事件
writeStream.on("error", (err) => {
  console.log("写入文件发生错误:", err);
});

// 补充：还可以监听 drain 事件
// 当写入的数据大小超过缓冲区大小时，write() 方法会返回 false
// 此时应该暂停写入，等待 drain 事件触发后再继续写入
writeStream.on("drain", () => {
  console.log("缓冲区已排空，可以继续写入数据");
});
