/*
  一、先回顾下Dart里的库（Library）和包（Package）
  在Dart里，一个dart文件天然就是一个库 <=> 具备单独的作用域 <=> 有自己的命名空间，具体地说：
  * 某个dart文件里的变量名和函数名可以跟全局作用域里的变量名和函数名重复、不会报重复定义的错，就是因为这个dart文件有单独的作用域、不会污染全局作用域
  * 多个dart文件里的变量名和函数名可以重复、不会报重复定义的错，就是因为这多个dart文件有单独的作用域、不会互相污染
  * 如果要在同一个作用域里使用重复的变量名和函数名，我们可以通过“import as”给库取别名的方式来避免冲突
  * 使用export导出，库里私有的变量和函数不会被导出，公开的变量和函数会被全部导出
  * 使用import导入，可以访问公开的变量和函数
  
  在Dart里，包是一个比库粒度更大的概念，通常是很多库的集合，通过pub.dev或私有仓库来管理
  这也是为啥我们在import某个库时，发现前面总是有个"package:"的缘故，因为库本身就在包里面嘛

  比如我们编写的base_flutter其实就是一个“包”，这个包里集合了很多“库”——UI库、网络库、路由库、Util库等等
  然后我们会在base_flutter.dart这个文件里（或者叫base_flutter.dart这个库里）用library关键字表明base_flutter.dart这个库是base_flutter这个包的主库，并在主库里export出所有我们希望被外界访问的其它库，这样外界在使用base_flutter这个包时就可以把base_flutter这个包视作一个整体而不是一堆零散的库、也就是说只import主库就可以了
*/

/*
  二、JS里的模块（Module）和包（Package）
  JS里的模块类似于Dart里的库，但JS里一个js文件并非天然就是一个模块 <=> 不具备单独的作用域 <=> 没有自己的命名空间，即默认没有模块化，说白了：
  所有的JS代码别看着写到了一个一个的js文件里，但其实它们还是共享全局作用域的，所以就算在不同的js文件里我们也不能定义重复的变量名和函数名，一重复就报错
  
  JS里的包类似于Dart里的包，通常是很多模块的集合，通过npm（Node Package Manager）或私有仓库来管理
*/

/*
  三、模块化和包管理
  接下来我们就先学习JS里的模块化——即让一个js文件成为一个模块 <=> 具备单独的作用域 <=> 有自己的命名空间
  然后再学习JS里的包管理
*/