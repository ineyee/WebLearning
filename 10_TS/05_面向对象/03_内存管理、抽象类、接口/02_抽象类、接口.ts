// JS里没有抽象类、接口的概念
// TS里新增了这两个概念

// 一、抽象类
abstract class Person {
  age: number = 0;

  abstract work(): void;
}

class Stuedent extends Person {
  work() {
    console.log("我是学生，我在学习");
  }
}

/*
  抽象类的应用场景：
  如果很多个类里面有很多重复的东西，比如重复的成员变量、重复的成员函数，那我们就可以考虑定义一个父类出来，把这些重复的成员变量和成员函数抽取到父类里。那你可能会问如果仅仅是这样的话，这个父类是个普通的父类就行了，没必要搞成抽象类啊，是的，在OC和Swift里面是没有抽象类这个概念的，所以这个抽取父类的操作就仅仅会止步于简单地抽取成个普通的父类，也就是说止步于此也是没什么大问题的。

  但是如果父类只是一个普通的父类，它有两个不太好的地方：

  这个父类可以被实例化，但很多时候这个父类是不应该被实例化的，因为这个父类真得是个很抽象的东西啊，它的实例没有任何意义，一会我们会举例子
  父类里如果有一些必须被子类实现的方法、不实现的话功能就无法正常运转，可是普通的父类又无法要求子类必须重写它的某些方法，那就得完全靠程序员来保证这些必须实现的方法都实现了，这就存在不实现的风险
  因此如果我们在“止步于此”的基础上再进一步，把那个普通的父类升级成为一个抽象类，就可以利用抽象类的特点顺利解决这两个问题了：

  抽象类不能被实例化，所以如果有哪个开发者写法不规范，把抽象类实例化了，那编译器就会报错
  我们可以把那些子类必须实现的方法定义成抽象方法，这样子类一旦没实现，编译器就会报错，而不用我们程序员自己去担心这回事
  所以总得来说抽象类的应用场景应该是这样的：

  第一步：如果很多个类里面有很多重复的东西，比如重复的成员变量、重复的成员函数，那我们就可以考虑定义一个父类出来，把这些重复的成员变量和成员函数抽取到父类里
  第二步：我们再考虑一下这个父类本身有没有被实例化的意义，如果没有那就果断把父类升级为抽象类，如果有就止步于此
  第三步：当我们已经把一个父类升级为抽象类之后，再进一步，那就是它里面必须被子类实现的方法搞成抽象方法，这样子类是否实现交给编译器去帮我们判断，因为我们自己很容易漏掉实现，从而导致功能缺失
*/

// 二、接口
interface Runnable {
  run(): void;
}

class Teacher implements Runnable {
  run(): void {
    console.log("我是老师，我在跑步");
  }
}

class Dog implements Runnable {
  run(): void {
    console.log("我是狗，我在奔跑");
  }
}

/*
  如果很多个类里面有很多重复的成员函数，那我们就可以考虑定义一个接口出来，把这些重复的成员函数抽取到接口里。那你可能会问如果仅仅是这样的话，我们为什么非要抽一个接口出来呢？抽一个父类或抽象父类出来不也行吗？的确如此，使用它们都能实现同样的功能，但有的时候更应该使用父类或抽象父类，而有的时候则更应该使用接口，这样写出来的代码就不仅停留在实现了功能层面，而是更加具备编程思想、更加利于代码的阅读。那什么时候使用父类或抽象父类？什么时候使用接口？

  第一步：如果很多个类里面有很多重复的成员变量、重复的成员函数，我们想把它们抽出来就只能使用父类或抽象父类，因为接口里只能有函数而不能有成员变量，而父类或抽象父类里就既可以有成员变量也可以有成员函数，至于该用父类还是抽象父类见上面“抽象类的应用场景
  第二步：如果很多个类里面有很多重复的成员函数，我们想把它们抽出来就既能使用父类或抽象父类，也能使用接口，此时就要看这多个类之间是不是同一类东西了。我们举个例子，比如说Student和Teacher这两个类都有run函数，那我们在为它们俩抽取公共函数的时候就更应该使用父类或抽象父类Person，因为从语义上来说Student和Teacher是同一类东西，至于该用父类还是抽象父类见上面“抽象类的应用场景；但是如果Student和Car这两个类都有run函数，那我们在为它们俩抽取公共函数的时候就更应该是使用接口Runnable，而不是定义一个什么BaseObject之类古怪的抽象类让它俩继承（虽然真得可以这么做，但不是很好理解），因为从语义上来说Student和Car压根不是同一类东西、不同世界里的两个类，它们只是都具备run的能力而已
*/
